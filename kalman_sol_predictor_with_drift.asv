%% ------------------------------------------------------------------------
%
% Constant Velocity Kalman Filter for 15-Minute Price Data
%
% This script is adapted for high-frequency (15-minute) data by correctly
% defining the time step 'dt' as a fraction of a day.
%
% -------------------------------------------------------------------------

clear; clc; close all;

%% --- 1. Load and Prepare Data ---

data = readtable('sol_ada_data.csv'); % Ensure this CSV has 15-minute data
sol_price = data.SOL_USD_Binance;
time_vector = data.datetime;

% Handle missing data
nan_indices = isnan(sol_price);
sol_price = sol_price(~nan_indices);
time_vector = time_vector(~nan_indices);

z = sol_price; % Measurements

%% --- 2. Split Data ---

split_ratio = 2/3;
split_idx = floor(length(z) * split_ratio);

train_data = z(1:split_idx);
validation_data = z(split_idx+1:end);
validation_length = length(validation_data);


%% --- 3. Define the Constant Velocity Kalman Filter Model ---

% --- CHANGE 1: Define dt as a fraction of a day ---
% The time step is now 15 minutes. There are 1440 minutes in a day.
dt = 15 / 1440;

% State transition matrix for constant velocity model
A = [1, dt; 0, 1];

% Measurement matrix (we only measure price)
H = [1, 0];

% --- Estimate Noise Covariances ---
% R: Measurement noise. Estimated from the variance of 15-minute price changes.
R = var(diff(train_data));

% Q: Process noise. Represents our uncertainty in the constant velocity model.
% The 'accel_variance' is the main tuning parameter for filter response.
accel_variance = 0.5; % TUNABLE: Increase for more responsiveness, decrease for more smoothness.
G = [dt^2/2; dt];     % Noise gain matrix
Q = G * G' * accel_variance;

% --- Initialize the Filter ---
% Initial state: [price; velocity]
initial_price = train_data(1);

% --- CHANGE 2: Scale initial velocity to be in units of $/day ---
% Calculate average change over 15 mins, then scale up to a full day.
intervals_in_day = 1440 / 15;
initial_velocity = mean(diff(train_data(1:10))) * intervals_in_day;
x_hat = [initial_price; initial_velocity];

% Initial error covariance
P = eye(2) * R;


%% --- 4. Run the Kalman Filter ---

% (This section requires no changes as 'A' and 'Q' are already updated)

% Prepare arrays to store results
prediction_1_step = zeros(validation_length, 1);
prediction_2_step = zeros(validation_length, 1); % Predicts 30 mins ahead
    
% Store estimation error and covariance
estimation_error = zeros(validation_length, 1);
price_variance = zeros(validation_length, 1);
velocity_variance = zeros(validation_length, 1);

% Run over training data to let the filter converge
for k = 1:split_idx
    x_hat_minus = A * x_hat;
    P_minus = A * P * A' + Q;
    K_gain = P_minus * H' / (H * P_minus * H' + R);
    x_hat = x_hat_minus + K_gain * (train_data(k) - H * x_hat_minus);
    P = (1 - K_gain * H) * P_minus;
end

% Run over validation data, making predictions
for k = 1:validation_length
    % Predict 1 step (15 mins) into the future
    x_pred_1 = A * x_hat;
    prediction_1_step(k) = x_pred_1(1);

    % Predict 2 steps (30 mins) into the future
    x_pred_2 = A * x_pred_1;
    prediction_2_step(k) = x_pred_2(1);

    % Update the filter with the actual measurement for the current step
    P_minus = A * P * A' + Q;
    K_gain = P_minus * H' / (H * P_minus * H' + R);
    x_hat = x_pred_1 + K_gain * (validation_data(k) - H * x_pred_1);
    P = (1 - K_gain * H) * P_minus;

    % --- Store metrics for analysis ---
    estimation_error(k) = validation_data(k) - x_hat(1); % Error of the final state estimate
    price_variance(k) = P(1,1);
    velocity_variance(k) = P(2,2);
end


%% --- 5. Calculate and Display Performance Metrics ---

% Prediction errors
error_1_step = validation_data - prediction_1_step;
error_2_step = validation_data(1:end-1) - prediction_2_step(1:end-1); % Adjust for 2-step offset

% Metrics for 1-step prediction
mse_1_step = mean(error_1_step.^2);
rmse_1_step = sqrt(mse_1_step);
mae_1_step = mean(abs(error_1_step));

% Metrics for 2-step prediction
mse_2_step = mean(error_2_step.^2);
rmse_2_step = sqrt(mse_2_step);
mae_2_step = mean(abs(error_2_step));

% Display metrics in the console
fprintf('--- 1-Step (15 min) Prediction Performance ---\n');
fprintf('Mean Squared Error (MSE) - (USD^2):     %.4f\n', mse_1_step);
fprintf('Root Mean Squared Error (RMSE) - (USD): %.4f\n', rmse_1_step);
fprintf('Mean Absolute Error (MAE) - (USD):      %.4f\n\n', mae_1_step);

fprintf('--- 2-Step (30 min) Prediction Performance ---\n');
fprintf('Mean Squared Error (MSE) - (USD^2):     %.4f\n', mse_2_step);
fprintf('Root Mean Squared Error (RMSE) - (USD) : %.4f\n', rmse_2_step);
fprintf('Mean Absolute Error (MAE) - (USD):      %.4f\n\n', mae_2_step);


%% --- 6. Visualize the Results ---

validation_time = time_vector(split_idx+1:end);

% --- PLOT 1: Main Prediction Plot ---
figure('Position', [100, 100, 1200, 600], 'Name', 'Kalman Filter Predictions');
hold on;
plot(time_vector(1:split_idx), train_data, 'b-', 'DisplayName', 'Training Data');
plot(validation_time, validation_data, 'g-', 'LineWidth', 2, 'DisplayName', 'Validation Data (Actual)');
plot(validation_time, prediction_1_step, 'r--', 'LineWidth', 1.5, 'DisplayName', '1-Step (15 min) Prediction');
plot(validation_time, prediction_2_step, 'm:', 'LineWidth', 1.5, 'DisplayName', '2-Step (30 min) Prediction');
xline(time_vector(split_idx), 'k--', 'LineWidth', 1.5, 'DisplayName', 'Train/Validation Split');
title('Kalman Filter Multi-Step Prediction (15-Minute Data)');
xlabel('Date');
ylabel('Price (USD)');
legend('show', 'Location', 'northwest');
grid on;
hold off;

% --- PLOT 2: Prediction Error Over Time ---
figure('Position', [100, 100, 1200, 500], 'Name', 'Prediction Error Over Time');
hold on;
plot(validation_time, error_1_step, 'r-', 'DisplayName', '1-Step (15 min) Error');
plot(validation_time(1:end-1), error_2_step, 'm-', 'DisplayName', '2-Step (30 min) Error');
yline(0, 'k--', 'DisplayName', 'Zero Error');
title('Prediction Error Over Time');
xlabel('Date');
ylabel('Error (USD)');
grid on;
legend('show', 'Location', 'best');
hold off;

% --- PLOT 3: Running Mean Squared Error ---
figure('Position', [100, 100, 1200, 500], 'Name', 'Running Mean Squared Error');
running_mse_window = 30; % Use a 30-period window
running_mse_1_step = movmean(error_1_step.^2, running_mse_window);
running_mse_2_step = movmean(error_2_step.^2, running_mse_window);
hold on;
plot(validation_time, running_mse_1_step, 'b-', 'DisplayName', 'Running MSE (1-Step)');
plot(validation_time(1:end-1), running_mse_2_step, 'c-', 'DisplayName', 'Running MSE (2-Step)');
title(['Running Mean Squared Error (Window = ' num2str(running_mse_window) ' periods)']);
xlabel('Date');
ylabel('MSE');
grid on;
legend('show', 'Location', 'best');

% --- PLOT 4: Error Histogram ---
figure('Position', [100, 100, 800, 600], 'Name', 'Error Distribution');
histogram(error_1_step, 50); % 50 bins
title('Histogram of 1-Step Prediction Errors');
xlabel('Prediction Error (USD)');
ylabel('Frequency');
grid on;

% --- PLOT 5: State Covariance (Filter Uncertainty) ---
figure('Position', [100, 100, 1200, 500], 'Name', 'Filter State Uncertainty');
% Price Variance
subplot(2,1,1);
plot(validation_time, price_variance, 'b-');
title('Kalman Filter State Uncertainty: Price');
xlabel('Date');
ylabel('Price Variance (P_1_1)');
grid on;
% Velocity Variance
subplot(2,1,2);
plot(validation_time, velocity_variance, 'r-');
title('Kalman Filter State Uncertainty: Velocity');
xlabel('Date');
ylabel('Velocity Variance (P_2_2)');
grid on;